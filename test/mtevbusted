#!/bin/sh
--[[ 2>/dev/null
exec ../src/luamtev '-C../src/modules/mtev_lua/?.so;{package.cpath}' '-L../src/modules/lua-support/?.lua;./lua-harness/?.lua;{package.path}' '-M../src/modules/' $0 $@
]]

module(..., package.seeall)

local _G = _G
local __buf = ''
local io = io
local os = require('os')
local print = print
local pairs = pairs
local filename = os.getenv('JUNIT_OUTPUT_FILE') or 'test_detail.xml'
local previowrite = io.write
local mteviowrite = function(s)
  mtev.log("stdout", "%s", s)
end

local mtev = mtev
local nthreads = mtev.eventer_loop_concurrency()
local require = require
local pcall = pcall

jit.off(mtev.timeval.new)

if (os.getenv("LUA_PATH") ~= nil) then
  package.path = package.path .. ";" .. os.getenv("LUA_PATH")
end

local l = require("luarocks.loader")
l.add_context("busted", "2.0.rc12-1")

local busted = require('busted.core')();
local filterLoader = require 'busted.modules.filter_loader'()
local helperLoader = require 'busted.modules.helper_loader'()
local outputHandlerLoader = require 'busted.modules.output_handler_loader'()
local luacov = require 'busted.modules.luacov'()
require 'busted'(busted)

outputHandlerLoader(
  busted, 'junit',
  { arguments = { filename }, language = 'en' }
)
outputHandlerLoader(
  busted, 'gtest',
  { language = 'en' }
)

helperLoader(busted, 'lua-support/mtev_load.lua', { verbose = true, language = 'lua' })

local testFileLoader = require 'busted.modules.test_file_loader'(busted, { 'lua', 'moonscript' })
testFileLoader({ '.' }, { '_spec' }, { recursive = true, excludes = {} })

local function jobwatch()
  local todo = { }
  local fail = 0
  while true do
    local id, job, status, bad = mtev.waitfor('jobs', 1)
    if status == 'start' then
      todo[job] = 1
      fail = fail + bad
    end
    local cnt = 0
    for k,v in pairs(todo) do cnt = cnt + 1 end
    if cnt == 0 then
      mtev.log("test", "Jobs complete, failures: %d\n", fail)
      os.exit( fail == 0 and 0 or 2 )
    end
    if status == 'end' then
      todo[job] = nil
       fail = fail + bad
    end
  end
end
local tid, id = mtev.thread_self()
if id == 0 then
  mtev.coroutine_spawn(jobwatch)
end

function testsuite(context)
  local thread, tid = mtev.thread_self()
  local name = "testsuite-tid-" .. tid
  mtev.notify('jobs', name, 'start', 0)
  local failures = 0
  local errors = 0

  busted.subscribe({ 'error' }, function(...)
    errors = errors + 1
    return nil, true
  end)

  busted.subscribe({ 'test', 'end' }, function(...)
    if status == 'failure' then
      failures = failures + 1
    end
    return nil, true
  end)

  busted.subscribe({ 'suite', 'end' }, function (root, i, runs)
    local exit = 0
    if failures > 0 or errors > 0 then
      exit = 1
    end
    if context == "MAIN" then
      mtev.log("test", "%s testsuite finished\n", context)
    else
      mtev.log("test", "%s testsuite [%d/%d] finished\n", context, tid+1, nthreads)
    end
  end)

  busted.subscribe({ 'exit' }, function(...)
    mtev.notify('jobs', name, 'end', failures + errors)
  end)

  local execute = require 'busted.execute'(busted)
  execute(1, {
    seed = mtev.gettimeofday(),
    shuffle = true,
    sort = true,
  })
  busted.publish({ 'exit' })
end

function main()
  testsuite("MAIN")
end

